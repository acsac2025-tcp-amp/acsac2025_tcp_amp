import sys

packet_parse_result_file = open(sys.argv[1],'r') # result generated by pcap_parse.py
output_log_file = open(sys.argv[2],'w') # amplification factor result output file



lines = packet_parse_result_file.readlines()
packet_parse_result_file.close()

for line in lines:
    line = line.strip()
    line_list = line.split(';')
    
    if line_list[2]=='' or line_list==None: 
        # these are hosts that we didn't send the verify SYN packet to them, because our probing failed to see the response SYN-ACK packet.
        continue
    
    ip = line_list[0]
    tag = line_list[1]
    packet_list = line_list[2:]
    
    S_packet = None
    SA_packet = None

    for packet in packet_list:
        if 'S' in packet and 'Out' in packet:
            S_packet = packet 
            # our verify SYN packet
            # note that our probing packets is not captured in the pcap, we will include the cost of probing at the end of the processing.
            break
    
    
    for packet in packet_list:
        if 'SA' in packet and 'In' in packet:
            SA_packet = packet 
            # first SA packet sent by the server.
            break
            


    if S_packet!=None and SA_packet!=None: # for a normal host, we should see SYN and SYN-ACK packet, we use this for RTT estimation
        S_time = float(S_packet.split(',')[1]) # dispatch time of SYN
        SA_time = float(SA_packet.split(',')[1]) # recipient time of SYN-ACK
        RTT = SA_time - S_time

    else: 
        # there is a small fraction of host ~300 host succesfully send SYN-ACK during the probing but not sending a SYN-ACK for the verify SYN, we skip them.
        continue

    bytes_received = {
        50:None,
        100:None,
        200:None,
        150:None,
        500:None,
        1000:None,
        2000:None,
        'unresponsive':None
    }
    # key is the assumed RTT between a victim and a server 

    
    start_time = float(S_packet.split(',')[1]) # start time is when we send SYN packet
    SA_start_time = float(SA_packet.split(',')[1]) # when we receive the SYN-ACK packet from the server
        
    success_flag = False

    bytes_received[50] =   [SA_start_time-RTT/2.0+0.05, 0,0] # SA_start_time-RTT/2.0+0.05 is the estimated time the rst arrives at the reflector when rtt is 50, any payload pakets dispatched before the arrival time should be sent to the victim
    bytes_received[100] =  [SA_start_time-RTT/2.0+0.1, 0,0]
    bytes_received[200] =  [SA_start_time-RTT/2.0+0.2, 0,0] 
    bytes_received[150] =  [SA_start_time-RTT/2.0+0.15, 0,0]
    bytes_received[500] =  [SA_start_time-RTT/2.0+0.5, 0,0]
    bytes_received[1000] = [SA_start_time-RTT/2.0+1, 0,0]
    bytes_received[2000] = [SA_start_time-RTT/2.0+2, 0,0]
    bytes_received['unresponsive'] = [-1, 0, 0]
    

    input_syn_ack_isn = int(SA_packet.split(',')[3])
    output_ack_isn_list = []

    for packet in packet_list:
        if 'In' in packet:
            # packets from the server to our scanner

            pac_para_list = packet.split(',')
            pac_time = float(pac_para_list[1])
            pac_flags = pac_para_list[2]
            pac_len = int(pac_para_list[-1])

            if pac_len<=60: 
                pac_len = 64 
                # for any incoming packet that is less than 64bytes, normal ethernet should padded it to 64 bytes
            else:
                pac_len = pac_len+4
                # for any other packets, we add 4 bytes, as the FCS in ethernet header is stripped 

            rel_ack = int(pac_para_list[-2])
            pac_seq_left = int(pac_para_list[3])
            pac_seq_right = int(pac_para_list[4])



            if not ('R' in pac_flags or 'S' in pac_flags) and rel_ack>1 and (pac_seq_right - pac_seq_left >0): 
                # we skip syn or rst packet, and if the packet acknowledged our payload, relevant ack>1, and the sequence range is not 0 (the packet itself has a payload) we consider spoofing as successful
                success_flag=True

            # This is the estimated dispatch time of the packet
            # it is actually also ok to directly compare:
            # pac_time <= SA_start_time+0.05 directly when assuming a victim with 0.05s RTT with the server
            if pac_time-RTT/2 <= bytes_received[50][0]:
                bytes_received[50][1] = bytes_received[50][1] + pac_len
                # for responsive victim, we only count the pacekt in if it is received before connection may be terminated

            if pac_time-RTT/2 <= bytes_received[100][0]:
                bytes_received[100][1] = bytes_received[100][1] + pac_len

            if pac_time - RTT/2 <= bytes_received[200][0]:
                bytes_received[200][1] = bytes_received[200][1] + pac_len
            
            if pac_time - RTT/2 <= bytes_received[150][0]:
                bytes_received[150][1] = bytes_received[150][1] + pac_len

            if pac_time - RTT/2 <= bytes_received[500][0]:
                bytes_received[500][1] = bytes_received[500][1] + pac_len

            if pac_time - RTT/2 <= bytes_received[1000][0]:
                bytes_received[1000][1] = bytes_received[1000][1] + pac_len

            if pac_time - RTT/2 <= bytes_received[2000][0]:
                bytes_received[2000][1] = bytes_received[2000][1] + pac_len

            bytes_received['unresponsive'][1] = bytes_received['unresponsive'][1] + pac_len
            # for unresponsive victim, we count all packets
            

        elif 'Out' in packet:
            if 'R' in packet.split(',')[2]:
                print('something is wrong, we should not send any rst packet during verification')
            
            pac_para_list = packet.split(',')
            pac_flags = pac_para_list[2]

            # if pac_flags=='A':
            #     output_ack_isn_list.append((int(packet.split(',')[-2])-1) % (2**32)) 
            #     # get the ISN number used in our outgoing ACK packets, we sent b, then the guessed server ISN should be b-1


            pac_len = int(pac_para_list[-1])
            if pac_len<=60:
                pac_len = 64
            else:
                pac_len = pac_len+4


            # for outgoing packets, as we always send all spoofed packets in quick succession, the cost always includes every spoofed packet
            bytes_received[50][2] = bytes_received[50][2] + pac_len
            bytes_received[100][2] = bytes_received[100][2] + pac_len
            bytes_received[200][2] = bytes_received[200][2] + pac_len
            bytes_received[150][2] = bytes_received[150][2] + pac_len
            bytes_received[500][2] = bytes_received[500][2] + pac_len
            bytes_received[1000][2] = bytes_received[1000][2] + pac_len
            bytes_received[2000][2] = bytes_received[2000][2] + pac_len
            bytes_received['unresponsive'][2] = bytes_received['unresponsive'][2] + pac_len


    # if input_syn_ack_isn in output_ack_isn_list: 
    #     # we gussed the correct ISN, but server never acknowledged our request nor send us a reaponse
    #     if success_flag==False:
    #         print(ip,tag)


    
    
    if tag=='S' or tag=='Sc2' or tag=='Sc3' or tag=='D2':
        probe_cost = 64*2
        # for S, Sc2, Sc3, D2 types, we only send one probe SYN packet (+ 1 RST), so the probe cost is 64 * 2
        # the other cost by spoofed SYN, ACK, PSHACK is already counted
    else:
        probe_cost = 64 * 4 
        # for the rest, we need two SYN (+2 RST) for probing

    


    bytes_received[50][2] = bytes_received[50][2] + probe_cost
    bytes_received[100][2] = bytes_received[100][2] + probe_cost
    bytes_received[200][2] = bytes_received[200][2] + probe_cost
    bytes_received[150][2] = bytes_received[150][2] + probe_cost
    bytes_received[500][2] = bytes_received[500][2] + probe_cost
    bytes_received[1000][2] = bytes_received[1000][2] +probe_cost
    bytes_received[2000][2] = bytes_received[2000][2] +probe_cost
    bytes_received['unresponsive'][2] = bytes_received['unresponsive'][2] + probe_cost

    output_line = f"{ip},{success_flag},{float(bytes_received[50][1]/bytes_received[50][2])},{float(bytes_received[100][1]/bytes_received[100][2])},{float(bytes_received[200][1]/bytes_received[200][2])},{float(bytes_received[150][1]/bytes_received[150][2])},{float(bytes_received[500][1]/bytes_received[500][2])},{float(bytes_received[1000][1]/bytes_received[1000][2])},{float(bytes_received[2000][1]/bytes_received[2000][2])},{float(bytes_received['unresponsive'][1]/bytes_received['unresponsive'][2])}\n"
    output_log_file.write(output_line)

